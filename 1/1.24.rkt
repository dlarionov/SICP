#lang racket
(define (square x) (* x x)) 

(define (expmod base exp m) 
  (cond ((= exp 0) 1) 
        ((even? exp)
         (remainder (square (expmod base (/ exp 2) m)) m)) 
        (else 
         (remainder (* base (expmod base (- exp 1) m)) m))))  

(define (prime? n)
  (define (next) (random (- n 1)))
  (define (iter a times)
    (if (> times 0)
        (if (= (expmod a n n) a)
            (iter (next) (- times 1))
            false)
        true))
  (iter (next) 100000))

(define (test n)
  (define (runtime) 
    (current-milliseconds))
  (define (start time)
    (define (report-true x)
      (display x)
      (display " : ")
      (display (- (runtime) time))
      (newline)
      true)
    (if (prime? n)
        (report-true n)
        false))
  (start (runtime)))

(define (search-for-primes from count)
  (define (iter v i)
    (cond [(> i 0)        
           (if (test v)
               (iter (+ v 1) (- i 1))
               (iter (+ v 1) i))]))
  (iter from count))

(search-for-primes 1000 1)
(search-for-primes 10000 1)
(search-for-primes 100000 1)
(search-for-primes 1000000 1)
(search-for-primes 10000000 1)
(search-for-primes 100000000 1)
(search-for-primes 1000000000 1)