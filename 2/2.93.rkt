#lang racket

(define *table (make-hash))
(define (put op type proc) (hash-set! *table (list op type) proc))
(define (get op type) (hash-ref *table (list op type) '()))

(define (attach-tag type-tag contents)
  (if (eq? type-tag 'integer)
      contents
      (cons type-tag contents)))
(define (type-tag datum)
  (if (and (number? datum) (= (round datum) datum))
      'integer
      (car datum)))
(define (contents datum)
  (if (and (number? datum) (= (round datum) datum))
      datum
      (cdr datum)))

(define (apply-generic op . args)  
  (define (apply-generic-internal local-args)
    (let ((type-tags (map type-tag local-args)))
      (let ((proc (get op type-tags)))
        (if (null? proc)
            '()
            (apply proc (map contents local-args))))))
  (let ((result1 (apply-generic-internal args)))
    ;(print (list 'apply-generic op args))
    ;(newline)
    (if (null? result1)
        (let ((types (remove-duplicates (map type-tag args))))
          (if (> (length types) 1)              
              (let ((result2 (apply-generic-internal (raise-args args))))
                (if (null? result2)                    
                    (error "No method for these types" (cons op (map type-tag args)))
                    result2))
              (error "No method for these types" (cons op (map type-tag args)))))
        result1)))

(define (add x y) (apply-generic 'add x y))
(define (sub x y) (apply-generic 'sub x y))
(define (mul x y) (apply-generic 'mul x y))
(define (div x y) (apply-generic 'div x y))
(define (equ? x y) (apply-generic 'equ? x y))
(define (zero? x) (apply-generic 'zero? x))
(define (negate x) (apply-generic 'negate x))

(define (raise z) (apply-generic 'raise z))
(define (raise-index x)
  (define (iter i type guess)
    (let ((guess-type (type-tag guess)))
      (if (eq? type guess-type)
          i
          (iter (+ i 1) guess-type (raise guess)))))
  (iter 0 (type-tag x) (raise x)))
(define (raise-to-index i x)
  (if (= (raise-index x) i)
      x
      (raise-to-index i (raise x))))
(define (raise-args args)
  (let ((i (apply min (map raise-index args))))
    (map (lambda(x) (raise-to-index i x)) args)))

(define (project z) (apply-generic 'project z))
(define (drop z)
  (let ((p (project z)))
    (if (eq? (type-tag z) (type-tag p))
        z
        (drop p))))

(define (real-part z) (apply-generic 'real-part z))
(define (imag-part z) (apply-generic 'imag-part z))
(define (magnitude z) (apply-generic 'magnitude z))
(define (angle z) (apply-generic 'angle z))

(define (coeff term) (apply-generic 'coeff term))
(define (order term) (apply-generic 'order term))
(define (first-term terms) (apply-generic 'first-term terms))
(define (rest-terms terms) (apply-generic 'rest-terms terms))
(define (adjoin-term term terms) (apply-generic 'adjoin-term term terms))
(define (empty? terms) (apply-generic 'empty? terms))
(define (reduce terms) (apply-generic 'reduce terms))

(define (install-integer-package)
  (define (make-rational n d) ((get 'make 'rational) n d))
  
  (define (tag x) (attach-tag 'integer x))
  (put 'make 'integer (lambda (x) (tag x)))
  (put 'add '(integer integer) (lambda (x y) (tag (+ x y))))
  (put 'sub '(integer integer) (lambda (x y) (tag (- x y))))
  (put 'mul '(integer integer) (lambda (x y) (tag (* x y))))
  (put 'div '(integer integer) (lambda (x y) (make-rational x y)))
  (put 'equ? '(integer integer) (lambda (x y) (= x y)))
  (put 'zero? '(integer) (lambda (x) (= x 0)))
  (put 'raise '(integer) (lambda (x) (make-rational x 1)))
  (put 'project '(integer) (lambda (x) (tag x)))
  (put 'negate '(integer) (lambda (x) (tag (- x))))
  )

(define (install-rational-package)
  (define (make-integer x) ((get 'make 'integer) x))
  (define (make-real x) ((get 'make 'real) x))
  
  (define (make-rat n d) (cons n d))
  (define numer car)
  (define denom cdr)
  
  (define (add-rat x y) (make-rat (add (mul (numer x) (denom y)) (mul (numer y) (denom x))) (mul (denom x) (denom y))))
  (define (sub-rat x y) (make-rat (sub (mul (numer x) (denom y)) (mul (numer y) (denom x))) (mul (denom x) (denom y))))
  (define (mul-rat x y) (make-rat (mul (numer x) (numer y)) (mul (denom x) (denom y))))
  (define (div-rat x y) (make-rat (mul (numer x) (denom y)) (mul (denom x) (numer y))))
 
  (define (tag x) (attach-tag 'rational x))
  (put 'make 'rational (lambda (n d) (tag (make-rat n d))))
  (put 'add '(rational rational) (lambda (x y) (tag (add-rat x y))))
  (put 'sub '(rational rational) (lambda (x y) (tag (sub-rat x y))))
  (put 'mul '(rational rational) (lambda (x y) (tag (mul-rat x y))))
  (put 'div '(rational rational) (lambda (x y) (tag (div-rat x y))))
  (put 'equ? '(rational rational) (lambda (x y) (and (equ? (numer x) (numer y))(equ? (denom x) (denom y)))))
  (put 'zero? '(rational) (lambda (x) (zero? (numer x))))
  (put 'raise '(rational) (lambda (x) (if (and (number? (numer x)) (number? (denom x)))
                                          (make-real (/ (numer x) (denom x)))
                                          (tag x))))
  (put 'project '(rational) (lambda (x)
                              (cond ((and (number? (numer x)) (= (numer x) 0))
                                     (make-integer 0))
                                    ((and (number? (denom x)) (= (denom x) 1))
                                     (if (number? (numer x))
                                         (make-integer (numer x))
                                         (numer x)))
                                    (else (tag x)))))
  (put 'negate '(rational) (lambda (x) (tag (make-rat (negate (numer x)) (denom x)))))
  )

(define (install-real-package)
  (define (make-integer x) ((get 'make 'integer) x))
  (define (make-complex x y) ((get 'make-from-real-imag 'complex) x y))
  
  (define (tag x) (attach-tag 'real x))
  (put 'make 'real (lambda (x) (tag x)))
  (put 'add '(real real) (lambda (x y) (tag (+ x y))))
  (put 'sub '(real real) (lambda (x y) (tag (- x y))))
  (put 'mul '(real real) (lambda (x y) (tag (* x y))))
  (put 'div '(real real) (lambda (x y) (tag (/ x y))))
  (put 'equ? '(real real) (lambda (x y) (= x y)))
  (put 'zero? '(real) (lambda (x) (= x 0)))
  (put 'raise '(real) (lambda (x) (make-complex x 0)))
  (put 'project '(real) (lambda(x) (if (= (round x) x) (make-integer x) (tag x))))
  (put 'negate '(real) (lambda (x) (tag (- x))))
  )

(define (install-rectangular-package)
  (define (square x) (* x x))
  
  (define (real-part z) (car z))
  (define (imag-part z) (cdr z))
  (define (make-from-real-imag x y) (cons x y))
  (define (magnitude z) (sqrt (+ (square (real-part z)) (square (imag-part z)))))
  (define (angle z) (atan (imag-part z) (real-part z)))
  (define (make-from-mag-ang r a) (cons (* r (cos a)) (* r (sin a))))

  (define (tag x) (attach-tag 'rectangular x))
  (put 'make-from-real-imag 'rectangular (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'rectangular (lambda (r a) (tag (make-from-mag-ang r a))))
  (put 'real-part '(rectangular) real-part)
  (put 'imag-part '(rectangular) imag-part)
  (put 'magnitude '(rectangular) magnitude)
  (put 'angle '(rectangular) angle)
  )

(define (install-polar-package)
  (define (magnitude z) (car z))
  (define (angle z) (cdr z))
  (define (make-from-mag-ang r a) (cons r a))
  (define (real-part z) (* (magnitude z) (cos (angle z))))
  (define (imag-part z) (* (magnitude z) (sin (angle z))))
  (define (make-from-real-imag x y) (cons (sqrt (+ (* x x) (* y y))) (atan y x)))
  
  (define (tag x) (attach-tag 'polar x))
  (put 'make-from-real-imag 'polar (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'polar (lambda (r a) (tag (make-from-mag-ang r a))))
  (put 'real-part '(polar) real-part)
  (put 'imag-part '(polar) imag-part)
  (put 'magnitude '(polar) magnitude)
  (put 'angle '(polar) angle)  
  )

(define (install-complex-package)
  (define (make-real x) ((get 'make 'real) x))
  (define (make-from-real-imag x y) ((get 'make-from-real-imag 'rectangular) x y))
  (define (make-from-mag-ang r a) ((get 'make-from-mag-ang 'polar) r a))

  (define (add-complex z1 z2) (make-from-real-imag (+ (real-part z1) (real-part z2)) (+ (imag-part z1) (imag-part z2))))
  (define (sub-complex z1 z2) (make-from-real-imag (- (real-part z1) (real-part z2)) (- (imag-part z1) (imag-part z2))))
  (define (mul-complex z1 z2) (make-from-mag-ang (* (magnitude z1) (magnitude z2)) (+ (angle z1) (angle z2))))
  (define (div-complex z1 z2) (make-from-mag-ang (/ (magnitude z1) (magnitude z2)) (- (angle z1) (angle z2))))
  
  (define (tag x) (attach-tag 'complex x))
  (put 'make-from-real-imag 'complex (lambda (x y) (tag (make-from-real-imag x y))))
  (put 'make-from-mag-ang 'complex (lambda (x y) (tag (make-from-mag-ang x y))))
  (put 'add '(complex complex) (lambda (z1 z2) (tag (add-complex z1 z2))))
  (put 'sub '(complex complex) (lambda (z1 z2) (tag (sub-complex z1 z2))))
  (put 'mul '(complex complex) (lambda (z1 z2) (tag (mul-complex z1 z2))))
  (put 'div '(complex complex) (lambda (z1 z2) (tag (div-complex z1 z2))))
  (put 'real-part '(complex) real-part)
  (put 'imag-part '(complex) imag-part)
  (put 'magnitude '(complex) magnitude)
  (put 'equ? '(complex complex) (lambda (x y) (and (= (real-part x) (real-part y)) (= (imag-part x) (imag-part y)))))
  (put 'zero? '(complex) (lambda (x) (= (magnitude x) 0)))
  (put 'angle '(complex) angle)
  (put 'raise '(complex) (lambda (x) (tag x)))
  (put 'project '(complex) (lambda (x) (if (= (imag-part x) 0) (make-real (real-part x)) (tag x))))
  (put 'negate '(complex) (lambda (x) (mul -1 (tag x))))
  )

(define (install-terms-package)
  (define (make-term order coeff) (list order coeff))
  (define (order term) (car term))
  (define (coeff term) (cadr term))

  (define (install-dense-package)
    (define (adjoin-term term terms)      
      (let ((len (length terms)))
        (cond ((= len (order term)) (tag (cons (coeff term) terms)))
              ((< len (order term)) (adjoin-term term (cons 0 terms)))
              ((> len (order term)) (error ("terms length more than term order"))))))

    (define (reduce terms)      
      (if (zero? (car terms))
          (reduce (cdr terms))
          terms))
    
    (define (tag x) (attach-tag 'dense-terms x))
    (put 'make 'dense-terms (lambda(x) (tag x)))
    (put 'first-term '(dense-terms) (lambda(x) (tag-term (make-term (length (cdr x)) (car x)))))
    (put 'rest-terms '(dense-terms) (lambda(x) (tag (cdr x))))
    (put 'adjoin-term '(term dense-terms) adjoin-term)
    (put 'empty? '(dense-terms) (lambda(x) (null? x)))
    (put 'negate '(dense-terms) (lambda (x) (tag (map negate x))))
    (put 'reduce '(dense-terms) (lambda(x) (tag (reduce x))))
    )
  
  (define (install-sparse-package)
    (define (adjoin-term term terms)
      (if (zero? (coeff term))
          terms
          (cons term terms)))
  
    (define (tag x) (attach-tag 'sparse-terms x))
    (put 'make 'sparse-terms (lambda(x) (tag x)))
    (put 'first-term '(sparse-terms) (lambda(x) (let ((i (car x)))(tag-term (make-term (order i) (coeff i))))))
    (put 'rest-terms '(sparse-terms) (lambda(x) (tag (cdr x))))
    (put 'adjoin-term '(term sparse-terms) (lambda(x y) (tag (adjoin-term x y))))
    (put 'empty? '(sparse-terms) (lambda(x) (null? x)))
    (put 'negate '(sparse-terms) (lambda (x) (tag (map (lambda(i) (make-term (order i) (negate (coeff i)))) x))))
    (put 'reduce '(sparse-terms) (lambda(x) (tag x)))
    )  
  
  (define (tag-term x) (attach-tag 'term x))
  (put 'make 'term (lambda(order coeff) (tag-term (make-term order coeff))))
  (put 'order '(term) order)
  (put 'coeff '(term) coeff)
  (put 'zero? '(term) (lambda(x) (zero? (coeff x))))

  (install-dense-package)
  (install-sparse-package)
  )

(define (install-polynomial-package)  
  (define (make-term order coeff) ((get 'make 'term) order coeff))
  
  (define (variable? x) (symbol? x))
  (define (same-variable? x y) (and (variable? x) (variable? y) (eq? x y)))
  
  (define (make-poly variable terms) (cons variable terms))
  (define (variable p) (car p))
  (define (term-list p) (cdr p))
  
  (define (add-terms L1 L2)
    (cond ((empty? L1) L2)
          ((empty? L2) L1)
          (else
           (let ((t1 (first-term L1)) 
                 (t2 (first-term L2)))            
             (cond ((> (order t1) (order t2)) (adjoin-term t1 (add-terms (rest-terms L1) L2)))
                   ((< (order t1) (order t2)) (adjoin-term t2 (add-terms L1 (rest-terms L2))))
                   (else (adjoin-term
                          (make-term (order t1) (add (coeff t1) (coeff t2)))
                          (add-terms (rest-terms L1) (rest-terms L2)))))))))
  
  (define (mul-terms L1 L2)
    (if (empty? L1)
        L1
        (add-terms 
         (mul-term-by-all-terms (first-term L1) L2)
         (mul-terms (rest-terms L1) L2))))

  (define (mul-term-by-all-terms t1 L)
    (if (empty? L)
        L
        (let ((t2 (first-term L)))
          (adjoin-term
           (make-term (+ (order t1) (order t2)) (mul (coeff t1) (coeff t2)))
           (mul-term-by-all-terms t1 (rest-terms L))))))

  (define (div-terms L1 L2)
    (if (empty? L1)
        (list L1 L1)
        (let ((t1 (first-term L1))
              (t2 (first-term L2)))
          (if (> (order t2) (order t1))
              (list (attach-tag (type-tag L1) '()) L1)
              (let ((new-coeff (drop (div (coeff t1) (coeff t2))))
                    (new-order (- (order t1) (order t2))))                
                (let ((mul-result (mul-term-by-all-terms (make-term new-order new-coeff) L2)))
                  (let ((rest-of-result (div-terms
                                         (reduce (add-terms L1 (negate mul-result)))
                                         L2)))
                    (list
                     (adjoin-term (make-term new-order new-coeff) (car rest-of-result))
                     (cadr rest-of-result)))
                  ))))))
  
  (define (add-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1) (add-terms (term-list p1) (term-list p2)))
        (error "variables are not the same")))
  
  (define (mul-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (make-poly (variable p1) (mul-terms (term-list p1) (term-list p2)))
        (error "variables are not the same")))

  (define (div-poly p1 p2)
    (if (same-variable? (variable p1) (variable p2))
        (let ((quotient-and-remainder (div-terms (term-list p1) (term-list p2))))          
          (list
           (make-poly (variable p1) (car quotient-and-remainder))
           (make-poly (variable p1) (cdr quotient-and-remainder))))
        (error "variables are not the same")))
  
  (define (zero-poly? p)
    (define (iter tail)
      (if (empty? tail)
          true
          (if (zero? (first-term tail))              
              (iter (rest-terms tail))
              false)))
    (iter (term-list p)))

  (define (negate-poly p) (make-poly (variable p) (negate (term-list p))))

  (define (tag x) (attach-tag 'polynomial x))
  (put 'make 'polynomial (lambda (var terms) (tag (make-poly var terms))))  
  (put 'add '(polynomial polynomial) (lambda (p1 p2) (tag (add-poly p1 p2))))
  (put 'mul '(polynomial polynomial) (lambda (p1 p2) (tag (mul-poly p1 p2))))
  (put 'sub '(polynomial polynomial) (lambda (p1 p2) (tag (add-poly p1 (negate-poly p2)))))
  (put 'div '(polynomial polynomial) (lambda (p1 p2) (let ((result (div-poly p1 p2))) (list (tag (car result)) (tag (cadr result))))))
  (put 'zero? '(polynomial) (lambda (x) (zero-poly? x)))
  (put 'negate '(polynomial) (lambda (x) (tag (negate-poly x))))
  )

(install-integer-package)
(install-real-package)
(install-rational-package)
(install-rectangular-package)
(install-polar-package)
(install-complex-package)
(install-terms-package)
(install-polynomial-package)

(define (make-rat n d) ((get 'make 'rational) n d))
(define (make-sparse-terms x) ((get 'make 'sparse-terms) x))
(define (make-dense-terms x) ((get 'make 'dense-terms) x))
(define (make-polynomial var terms) ((get 'make 'polynomial) var terms))

(define x1 (make-polynomial 'x (make-dense-terms (list 1 0 1))))
(define x2 (make-polynomial 'x (make-dense-terms (list 1 0 0 1))))
(define x3 (make-polynomial 'x (make-sparse-terms (list (list 2 1) (list 0 1)))))
(define x4 (make-polynomial 'x (make-sparse-terms (list (list 3 1) (list 0 1)))))

(add (make-rat x1 x2) (make-rat x1 x2))
(add (make-rat x3 x4) (make-rat x3 x4))